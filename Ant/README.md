# Ant Lab
## 问题描述
有一根300 厘米的细木杆，在第30 厘米、80 厘米、110 厘米、160 厘米、250厘米这五个位置上各有一只蚂蚁。木杆很细，不能同时通过两只蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝相反方向走。假设蚂蚁们每秒钟可以走5 厘米的距离。
请编写一个程序，计算各种可能情形下所有蚂蚁都离开木杆的最小时间和最大时间。
## 需求分析
游戏分为自选和自动两个模式：
自动模式下自动模拟蚂蚁爬杆问题32种情况的最大以及最小时间
自选模式下可以修改蚂蚁初始方向，仅模拟单种情况
用户可以调整游戏的速率（0.5X，1X，2X，4X）
用户可以中途暂停，继续，停止游戏
软件可以图形化展示蚂蚁爬行的过程
软件可以显示当前的轮次，时间，以及蚂蚁实时坐标信息
## 类的职责（按包分类）
### Entity
游戏中涉及到的游戏对象（蚂蚁，杆子）用**GameObject**抽象，包含位置信息，蚂蚁(**Ant**)和杆子(**Rod**)继承并且专有的属性，比如蚂蚁的速度，ID和杆子的长度。

### Physics
包含**Vector2D**以及**Collider**分别表示二维向量以及游戏物体的碰撞体信息

### Game
**PlayRoom**在这里作为启动游戏的类，同时也负责游戏上下文(**GameContext**)，游戏驱动(CreepingGame)，以及处理蚂蚁爬行等的类的创建，
**GameContext**作为游戏的上下文存储了游戏的基本信息，包括蚂蚁，杆子，游戏ID，游戏状态，游戏进行的时刻等信息。
**CreepingGame**作为游戏驱动类，同时也实现了Java中的Runnable接口可以作为主动类去运行游戏。**CreepingGame**中可以注册生命周期回调函数(**GameLifecycle**)的实例，**GameLifecycle**只包含三个生命周期回调函数，onCreate(), onUpdate(). onDestroy()，同时抽象出**GameLifecycle**的抽象类，增加**GameContext**和**CreepingGame**成员使得子类可以访问游戏的基本信息以及控制游戏。
**CreepingGame**在启动时会按注册的顺序调用所有的onCreate()方法，调用完之后会开启一个新线程运行游戏。新线程会按注册的顺序不断执行所有的onUpdate()方法，每执行完一轮onUpdate()游戏的时刻+1，如果用户请求终止游戏，**CreepingGame**会在一轮onUpdate()之后终止游戏并依次调用onDestroy()方法。

### Lifecycle
处理蚂蚁爬行(**CreepGameLifecycle**)，碰撞检测(**CreepGameLifecycle**)，记录离开木杆最大最小时间，控制台信息打印(**PrintGameLifecycle**)，更新界面(RenderGameLifecycle)等功能都通过实例化**GameLifecycle**接口实现。实际注册回调函数的时候需要注意先后顺序，先是蚂蚁的爬行，然后进行碰撞检测，然后再更新界面。
## 设计思想
CreepingGame采用注册，调用回调函数的形式可以减少代码的耦合度，使得蚂蚁爬行,检测碰撞的代码，记录最大最小时间的代码以及更新UI类的代码可以分开。同时更新UI和实际游戏逻辑也是分开的，更新UI逻辑只通过GameContext的信息以及回调函数来更新，对其他其他游戏逻辑没有侵入性。