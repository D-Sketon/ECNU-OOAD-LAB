# BlackJack Lab
## 问题描述
请编写一个程序，实现BlackJack游戏。
## 需求分析
游戏分为单人和多人两个模式：  
- 单人模式下，玩家独自一人和庄家（电脑）进行游戏
- 多人模式可以分为创建房间（作为服务器，在局域网内开启6668端口）和加入房间（通过连接端口加入游戏），不同玩家在同一个房间内和庄家（电脑）进行游戏，游戏数据在UI上实时共享
### 游戏规则：（和标准blackjack规则可能不同，故在此列出）
所有玩家初始金额1000元，游戏可持续进行，直到：
- 玩家主动退出
- 本金不足以下注
- 多人模式下玩家网络异常或长时间未下注
- 多人模式下房主结束游戏
- 其他异常情况
### 游戏下注
单人模式下可直接下注，无时间限制  
多人模式下除房主外有20秒的时间限制，超过20秒后自动断开连接，可重新加入  
下注金额不能超过本金
### 游戏开始
所有模式下所有玩家均下注后游戏才能开始  
初始状态下，为所有玩家（包括庄家）摸两张牌，庄家第一张为暗牌  
游戏进行中时按照UI上从左向右的顺序依次摸牌，直至所有玩家均停牌、爆牌或21点  
- 投降：初始阶段时可投降，投降后直接停牌
- 保险：初始阶段时，若庄家明牌为A，可选择保险（保险金0.5倍下注金额），保险后只可摸牌和停牌
- 加倍：初始阶段时可选择加倍，加倍同时会摸一张牌，加倍后只可摸牌和停牌
- 分牌：初始阶段时，若两张牌点数相同，可选择分牌，分牌后只可摸牌和停牌，最多分一次牌
- 摸牌：当总点数小于21点时均可摸牌
- 停牌：任意情况下可随时停牌
- 其他：
  - 牌的数量无限制
  - 一旦总点数大于等于21点，则直接进入下一个玩家
  - 加倍，分牌，保险若本金不够，则不允许进行
  - 若初始发牌时已经21点，则直接跳过本玩家
  - 20秒内没有操作自动停牌
### 游戏结算
结算分为保险结算和基础下注结算
#### 特殊情况
若一开始投降，则不论庄家是否爆牌，直接返还0.5倍下注金额
#### 保险结算
若一开始保险，且庄家blackjack，则返还1.5倍保险金额，否则不予返还
#### 基础下注结算
玩家手牌爆牌 或 庄家blackjack但玩家未blackjack 或 庄家未爆牌且玩家点数小于庄家，不予返还  
庄家和玩家均blackjack 或 庄家和玩家点数相同，返还1倍下注金额  
除去上述的情况下，若玩家blackjack，返还3倍下注金额，否则返还2倍下注金额  
### 游戏重新开始
单人模式下玩家可在重新下注后随时重新开始游戏  
多人模式下所有玩家均下注后房主才可重新开始游戏  
### 多人相关
以下情形均会导致连接中断：
- 尝试连接已经开始游戏的房间
- 尝试连接人数已满的房间
- 网络波动导致3次3秒内未能回复服务端心跳包
- 非房主20秒内未下注
- 主动关闭游戏进程
## 类的职责（按包分类）
### entity: 实体类的包，封装了游戏用到的数据
**Card**: 表示一张牌，包含面值和花色(Suit)  
**Hand**: 一手牌，里面包含玩家下注信息以及手牌（Card）列表  
**ActionParam**: 玩家与系统交互时传递的参数  
**RemoteParam**：联机时玩家与系统交互传递的参数  
**PlayerHandInfo**：玩家与系统交互时玩家手牌信息  
### player: 玩家类的包
**AbstractPlayer**：抽象玩家类，记录玩家筹码，手牌（Hand）信息等  
**Player**：表示由用户操作的玩家  
**Dealer**：表示庄家  
### enums: 枚举类的包
**GameEvent**：游戏事件，比如开始游戏、开始回合、摸牌等事件  
**GameMode**：游戏模式，包括单人和联机（加入其它游戏/主持游戏）  
**PlayerStatus**：玩家状态，空闲、加入游戏未下注、加入游戏已下注，根据状态判断是否可以开始游戏  
**Suit**：花色，黑桃、红桃、草花、方块以及特殊的NONE表示背面朝上的牌  
### game: 游戏核心相关
**GameEventAware**：接口，包含游戏各种事件的回调函数  
**AbstractGameEventHandler**: 抽象的游戏事件处理类，实现了GameEventAware，包括游戏上下文信息（GameContext）游戏客户端和服务端可以继承此类处理游戏事件。比如服务端（GameServer）可以通过回调函数处理游戏逻辑，客户端（GameClient）可以更新游戏信息，渲染界面，给玩家操作提示  
**GameContext**: 记录游戏上下文信息，包括游戏ID，玩家（AbstractPlayer）信息，以及发牌堆信息  
**GameServer**: 游戏的服务端，保存实际的游戏信息(玩家顺序，当前玩家序号等)，关于游戏的逻辑都在这个类中完成  
**GameClient**: 游戏的客户端，保存了服务端GameContext的副本，玩家对于游戏的操作都会通过与GameServer通信完成  
**GameUtil**: 游戏工具类，辅助GameServer进行逻辑判断  
### adapter: 客户端与服务端通信适配器
**CommunicationAdapter**: 客户端与服务端通信适配器接口类  
**LocalGameAdapter**: 本地游戏时客户端与服务端通信适配器，将消息克隆进行适配  
**RemoteGameAdapter**: 联机游戏时客户端与服务端通信适配器，会将消息进行序列化等操作进行通信适配  
### network: 联机用到的类
**ClientHandler**：Netty客户端处理事件类  
**ClientOnline**：客户端网络启动类  
**ServerHandler**：Netty服务端处理事件类  
**ServerOnline**：服务端网络启动类  
### ui: 界面相关
**MainController**：主要游戏界面  
**ConnectController**：连接他人游戏子窗口  
## 设计思想
对于需要界面的程序，依然采用游戏界面和逻辑分离的形式，游戏界面均位于ui包下，逻辑位于game包下，降低了UI和逻辑的耦合度。  
游戏支持单人游戏和多人联机，为此分出**GameServer**和**GameClient**两个类适配多人游戏，前者为游戏服务端保存游戏信息以及处理游戏逻辑，后者通过接受服务端的数据来保存游戏信息的副本并渲染界面。  
通信方面，在单人游戏时会同时启动**GameClient**和**GameServer**的实例，**GameClient**可以直接调用**GameServer**方法进行交互，联机时则会启动**GameClient**实例与**GameServer**通信，为解决通信适配的问题，引入了**CommunicationAdapter**接口。对于**GameClient**和**GameServer**处于一台主机时通过**LocalGameAdapter**进行适配，如果**GameClient**连接远程服务器，则通过**RemoteGameAdapter**适配。  
实际的游戏有很多操作，比如摸牌、加倍、分牌等，所以通信的消息采用**GameEvent**的事件形式，通过定义不同的事件类型实现服务端对客户端不同操作的识别以及客户端对服务端返回消息的识别。考虑到多人联机时的网络通信，事件的处理可能需要是异步的，需要通过实现**GameEventAware**接口中的回调函数来处理事件。  
UI标题和联机界面参考了著名游戏Minecraft。
## 类图
![Blackjack](https://fastly.jsdelivr.net/gh/D-Sketon/blog-img/Blackjack_ClassModel.png)
